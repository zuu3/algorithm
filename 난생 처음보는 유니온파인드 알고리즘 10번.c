//오늘은 새 학기 새로운 반에서 처음 시작하는 날이다. 현수네 반 학생은 N명이다. 현수는 각 학생들의 친구관계를 알고 싶다.
//모든 학생은 1부터 N까지 번호가 부여되어 있고, 현수에게는 각각 두 명의 학생은 친구 관계 가 번호로 표현된 숫자쌍이 주어진다.
//만약 (1, 2), (2, 3), (3, 4)의 숫자쌍이 주어지면 1번 학 생과 2번 학생이 친구이고, 2번 학생과 3번 학생이 친구, 3번 학생과 4번 학생이 친구이다.
//그리고 1번 학생과 4번 학생은 2번과 3번을 통해서 친구관계가 된다. 학생의 친구관계를 나타내는 숫자쌍이 주어지면 특정 두 명이 친구인지를 판별하는 프로그램 을 작성하세요.
//두 학생이 친구이면 “YES"이고, 아니면 ”NO"를 출력한다.
//▣ 입력설명 첫 번째 줄에 반 학생수인 자연수 N(1<=N<=1,000)과 숫자쌍의 개수인 M(1<=M<=3,000)이 주어지고,
//다음 M개의 줄에 걸쳐 숫자쌍이 주어진다. 마지막 줄에는 두 학생이 친구인지 확인하는 숫자쌍이 주어진다.
//▣ 출력설명 첫 번째 줄에 “YES"또는 "NO"를 출력한다. 
#include<stdio.h>
 
int n, parent[1001];  // n은 학생 수, parent 배열은 각 학생의 대표자를 저장하는 배열

// Find 함수: 주어진 학생의 대표자를 찾는 함수
// 경로 압축(Path Compression)을 사용하여 대표자를 빠르게 찾음
int Find(int v)
{
    if (parent[v] == v)  // 만약 학생 v가 자기 자신의 대표자라면
        return v;        // v가 대표자이므로 그대로 반환
    else
        return parent[v] = Find(parent[v]);  // 그렇지 않다면 v의 대표자를 재귀적으로 찾아서 경로 압축 수행
}

// Union 함수: 두 학생 x와 y를 같은 그룹으로 합치는 함수
void Union(int x, int y)
{
    x = Find(x);  // x의 대표자를 찾음
    y = Find(y);  // y의 대표자를 찾음
 
    if (x != y)   // 두 학생의 대표자가 다르면, 즉 서로 다른 그룹에 속해 있으면
        parent[x] = y;  // x의 대표자를 y로 설정하여 두 그룹을 합침
}

// Set 함수: 초기화 함수
// 모든 학생의 대표자를 자기 자신으로 초기화
void Set()
{
    int i;
 
    for (i = 1; i <= n; i++)  // 1번 학생부터 n번 학생까지 반복
        parent[i] = i;        // 각 학생의 대표자를 자기 자신으로 설정
}

int main(void)
{
    int m, i, a, b;
    
    // 학생 수 n과 친구 관계 수 m을 입력받음
    scanf("%d %d", &n, &m);
 
    Set();  // 모든 학생의 대표자를 자기 자신으로 초기화하는 Set 함수 호출
 
    for (i = 0; i < m; i++)  // m개의 친구 관계를 입력받아 처리하는 반복문
    {
        scanf("%d %d", &a, &b);  // 학생 a와 b의 친구 관계 입력
        Union(a, b);  // a와 b를 같은 그룹으로 합치는 Union 함수 호출
    }
 
    // 마지막으로 두 학생 a와 b가 같은 그룹에 속하는지 확인
    scanf("%d %d", &a, &b);
    if (Find(a) == Find(b))  // a와 b의 대표자가 같으면 같은 그룹에 속해 있으므로
        printf("YES\n");     // 친구 관계가 성립, "YES" 출력
    else
        printf("NO\n");      // 그렇지 않으면 친구 관계가 아님, "NO" 출력
 
    return 0;  // 프로그램 종료
}